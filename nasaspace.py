# -*- coding: utf-8 -*-
"""NasaSpace

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IA7bV6PNkfabesOozMbYPCbfC1Cfqhc5
"""

!pip install obspy

# Importando as bibliotecas necessárias
import numpy as np
import pandas as pd
from obspy import read
import matplotlib as mpl
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import os
import seaborn as sns
import sklearn

# Verificando as versões instaladas
print("NumPy version:", np.__version__)
print("Pandas version:", pd.__version__)
print("Matplotlib version:", mpl.__version__)
print("Scikit-learn version:", sklearn.__version__)
print("Seaborn version:", sns.__version__)

from google.colab import files

# Upload do arquivo "apollo12_catalog_GradeA_final.csv"
# Dados de treinamento para o conjunto de dados lunares
uploaded = files.upload()

import pandas as pd

# Lendo os dados de treinamento para o conjunto de dados lunares
df = pd.read_csv("apollo12_catalog_GradeA_final.csv", index_col=0)

# Exibir as primeiras linhas do DataFrame
print(df.head())

"""# **`Análise descritiva e gráfico dos dados`**

## **`Os três tipos de eventos de micro-sismos (mq_type) são:`**

- impact_mq (Eventos de Impacto)
- deep_mq (Eventos Profundos)
- shallow_mq (Eventos Superficiais)


### ***`1. impact_mq (Eventos de Impacto)`***
***`Descrição:`***
Eventos de impacto são normalmente associados a fenômenos que ocorrem devido a forças externas que afetam a superfície lunar. Esses eventos podem ser causados por:

- Impactos de Meteoritos: Quando um meteorito ou asteroide atinge a superfície lunar, gera ondas sísmicas que podem ser detectadas por instrumentos sismológicos. O tamanho e a velocidade do impacto influenciam a magnitude do evento sísmico.
- Atividades Humanas: Também podem incluir ruídos gerados por atividades humanas, como pousos de sondas ou explosões.

***`Importância:`***
- Estudo de Crateras: Analisar eventos de impacto ajuda a entender a formação de crateras e a dinâmica dos impactos na Lua.
- Avaliação de Riscos: Identificar e monitorar esses eventos é fundamental para avaliar riscos potenciais de impactos futuros.
### ***`2. deep_mq (Eventos Profundos)`***

***`Descrição:`***
Os eventos profundos ocorrem a grandes profundidades dentro da crosta lunar. Esses eventos são geralmente associados a processos geológicos que ocorrem mais abaixo da superfície, como:

- Movimentação de Rochas: Mudanças de pressão e temperatura que podem causar falhas ou movimentos nas rochas profundas.
- Atividade Vulcânica: Embora a atividade vulcânica na Lua seja menos frequente do que na Terra, eventos profundos podem estar associados a movimentos magmáticos.

***`Importância:`***
- Compreensão Geológica: Esses eventos fornecem informações sobre a estrutura interna da Lua e suas propriedades geológicas.
- Monitoramento de Atividades: A detecção de eventos profundos pode ajudar a identificar regiões de atividade geológica que podem ser de interesse para futuras missões.
###***`3. shallow_mq (Eventos Superficiais)`***

***`Descrição:`***
- Os eventos superficiais são aqueles que ocorrem perto da superfície lunar e são frequentemente associados a fenômenos mais superficiais, como:

- Terremotos Lunares: Podem ser causados por processos geológicos ou por impactos de meteoritos que provocam movimentos na crosta.
Deslizamentos ou Colapsos: Atividades que podem ocorrer devido a mudanças ambientais ou impactos.

***`Importância:`***
- Riscos e Segurança: Monitorar eventos superficiais é crucial para avaliar riscos em missões futuras e atividades humanas na Lua.
- Análise de Superfície: Esses eventos ajudam a entender a dinâmica da superfície lunar e como ela é afetada por processos internos e externos.
"""

# Número total de eventos
total_events = df.shape[0]
print("Total de eventos:", total_events)

# Distribuição dos tipos de eventos
event_distribution = df['mq_type'].value_counts()
print("\nDistribuição dos tipos de eventos:\n", event_distribution)

# Estatísticas básicas
stats = df['time_rel(sec)'].describe()
print("\nEstatísticas básicas do tempo relativo:\n", stats)

"""## **`Histograma do Tempo Relativo`**
`Descrição:`
Um histograma representa a distribuição dos tempos relativos dos eventos, agrupando-os em intervalos (bins) e contando quantos eventos caem em cada intervalo. O eixo x mostra os diferentes intervalos de tempo relativo, enquanto o eixo y indica a frequência de eventos em cada intervalo.

***`Objetivo:`***
- Visualizar Distribuição: Este gráfico fornece uma visão clara de como os tempos relativos estão distribuídos, permitindo identificar se a maioria dos eventos ocorre em intervalos curtos ou longos.
- Identificar Outliers: Facilita a identificação de outliers ou anomalias que possam indicar eventos únicos ou fora do padrão.

***`Interpretação:`***
- Uma distribuição normal pode indicar que os eventos ocorrem em intervalos relativamente consistentes, enquanto uma distribuição assimétrica pode sugerir variações nos intervalos de tempo.
- Um pico em intervalos específicos pode indicar que muitos eventos ocorrem em tempos semelhantes, sugerindo um fenômeno subjacente.
"""



plt.figure(figsize=(10, 6))
sns.histplot(df['time_rel(sec)'], bins=30, kde=True)
plt.title('Distribuição do Tempo Relativo')
plt.xlabel('Tempo Relativo (segundos)')
plt.ylabel('Frequência')
plt.show()

"""### ***`Gráfico de Linha do Tempo Absoluta`***
***`Descrição:`***
O gráfico de linha do tempo absoluta é uma visualização que mostra a relação entre o tempo absoluto dos eventos e o tempo relativo em segundos. Neste gráfico, o eixo x representa o tempo absoluto em que os eventos ocorreram, enquanto o eixo y mostra o tempo relativo, que é o intervalo de tempo entre eventos específicos.

***`Objetivo:`***
- Identificar Tendências: Este gráfico pode ajudar a identificar tendências ao longo do tempo, como se os eventos estão se tornando mais frequentes ou se os intervalos de tempo estão mudando.

- Análise de Padrões: Você pode observar padrões em momentos específicos, que podem indicar atividades anômalas ou comportamentos sazonais.

***`Interpretação:`***
- Linhas ascendentes podem indicar um aumento no tempo relativo à medida que o tempo absoluto avança, sugerindo que os eventos estão se tornando mais espaçados ou que a natureza dos eventos está mudando.
- Picos ou vales acentuados podem indicar eventos extraordinários ou anômalos.
"""

# Gráfico de Linha do Tempo Absoluta

df.columns = df.columns.str.strip()

# Converter a coluna de tempo absoluto para datetime
df['time_abs'] = pd.to_datetime(df['time_abs(%Y-%m-%dT%H:%M:%S.%f)'])


sns.set(style="whitegrid")

plt.figure(figsize=(14, 7))
sns.lineplot(data=df, x='time_abs', y='time_rel(sec)', marker='o')
plt.title('Tempo Relativo por Tempo Absoluto')
plt.xlabel('Tempo Absoluto')
plt.ylabel('Tempo Relativo (segundos)')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""## ***`Gráfico de Barras dos Tipos de MQ`***
***`Descrição:`***
O gráfico de barras exibe a contagem de diferentes tipos de eventos (mq_type) registrados no conjunto de dados. Cada barra representa um tipo de evento, e a altura da barra indica a quantidade de ocorrências desse tipo.

***`Objetivo:`***
- ***Comparar Tipos de Eventos:*** Este gráfico é útil para comparar visualmente a frequência de diferentes tipos de eventos e identificar quais são mais comuns.
- Análise de Comportamento: Pode ajudar a entender quais tipos de eventos predominam e, portanto, merecem mais atenção ou investigação.

***`Interpretação:`***
- Barras mais altas indicam que um tipo de evento específico ocorreu com mais frequência, enquanto barras mais baixas podem indicar tipos raros ou incomuns.
- Padrões podem emergir, como a predominância de eventos de impacto em comparação com outros tipos.

"""

plt.figure(figsize=(12, 6))
sns.countplot(data=df, x='mq_type', order=df['mq_type'].value_counts().index)
plt.title('Contagem de Tipos de MQ')
plt.xlabel('Tipo de MQ')
plt.ylabel('Contagem')
plt.xticks(rotation=45)
plt.show()

"""## ***`Gráfico de Dispersão entre Tempo Relativo e Tempo Absoluto`***
***`Descrição:`***
O gráfico de dispersão traça cada evento como um ponto, com o tempo absoluto no eixo x e o tempo relativo no eixo y. Os pontos podem ser coloridos de acordo com o tipo de evento (mq_type) para facilitar a análise.

***`Objetivo:`***
- Examinar Relações: Este gráfico ajuda a examinar se existe uma relação entre o tempo absoluto e o tempo relativo. Ele pode revelar como a distribuição dos tempos relativos varia em diferentes períodos de tempo.
- Identificar Agrupamentos: Permite identificar agrupamentos de eventos que podem indicar comportamentos específicos.

***`Interpretação:`***
- Padrões de agrupamento podem sugerir que certos tipos de eventos ocorrem em tempos específicos.
- A dispersão ampla dos pontos pode indicar uma variação significativa entre os eventos ao longo do tempo.
"""

plt.figure(figsize=(14, 7))
sns.scatterplot(data=df, x='time_abs', y='time_rel(sec)', hue='mq_type', alpha=0.7)
plt.title('Dispersão entre Tempo Absoluto e Tempo Relativo')
plt.xlabel('Tempo Absoluto')
plt.ylabel('Tempo Relativo (segundos)')
plt.xticks(rotation=45)
plt.legend(title='Tipo de MQ')
plt.tight_layout()
plt.show()

"""# ***`Filtragem e agrupamento`***"""

# Filtrar apenas eventos do tipo "impact_mq"
impact_events = df[df['mq_type'] == 'impact_mq']
print("Eventos do tipo 'impact_mq':\n", impact_events)

# Calcular a media relativa do tipo "impact_mq"
df_impact = df[df['mq_type'] == 'impact_mq']
average_time_impact = df_impact['time_rel(sec)'].mean()

print("\nTempo Relativo Médio para eventos do tipo 'impact_mq':", average_time_impact)

# Filtrar apenas eventos do tipo "deep_mq"
impact_events = df[df['mq_type'] == 'deep_mq']
print("Eventos do tipo 'deep_mq':\n", impact_events)

# Calcular a media relativa do tipo "deep_mq"
df_deep = df[df['mq_type'] == 'deep_mq']
average_time_deep = df_deep['time_rel(sec)'].mean()

print("\nTempo Relativo Médio para eventos do tipo 'deep_mq':", average_time_deep)

# Filtrar apenas eventos do tipo "shallow_mq"
impact_events = df[df['mq_type'] == 'shallow_mq']
print("Eventos do tipo 'shallow_mq':\n", impact_events)

# Calcular a media relativa do tipo "shallow_mq"
df_shallow = df[df['mq_type'] == 'shallow_mq']
average_time_shallow = df_shallow['time_rel(sec)'].mean()

print("\nTempo Relativo Médio para eventos do tipo 'shallow_mq':", average_time_shallow)

# Verificar dados faltantes
print(df.isnull().sum())

"""# Nova seção
### **Processamento de Sinal**
"""

import scipy.signal as signal

# Definir a frequência de corte (cutoff frequency)
cutoff_freq = 0.1  # frequência de corte
sampling_rate = 1  # taxa de amostragem

# Filtro passa-baixa
b, a = signal.butter(4, cutoff_freq, btype='low', fs=sampling_rate)

# Aplicar filtro nos dados 'time_rel(sec)'
df['filtered_time_rel'] = signal.filtfilt(b, a, df['time_rel(sec)'])


plt.figure(figsize=(14, 7))
plt.plot(df['time_abs'], df['time_rel(sec)'], label='Sinal Original')
plt.plot(df['time_abs'], df['filtered_time_rel'], label='Sinal Filtrado', color='red')
plt.title('Sinal Original vs. Sinal Filtrado (Filtro Passa-Baixa)')
plt.xlabel('Tempo Absoluto')
plt.ylabel('Tempo Relativo (segundos)')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Detectar picos no sinal filtrado
peaks, _ = signal.find_peaks(df['filtered_time_rel'], height=5000)  # ajustar altura conforme necessário

# Plotar os picos detectados
plt.figure(figsize=(14, 7))
plt.plot(df['time_abs'], df['filtered_time_rel'], label='Sinal Filtrado')
plt.plot(df['time_abs'][peaks], df['filtered_time_rel'][peaks], "x", label='Picos Detectados')
plt.title('Detecção de Picos no Sinal Filtrado')
plt.xlabel('Tempo Absoluto')
plt.ylabel('Tempo Relativo (segundos)')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Exibir os picos encontrados
print("Picos Detectados nas Seguintes Amostras (Tempo Absoluto):\n", df['time_abs'].iloc[peaks])

import numpy as np

# Função STA/LTA ajustada com 'same' no modo de convolução
def sta_lta(signal, nsta, nlta):
    sta = np.zeros(len(signal))
    lta = np.zeros(len(signal))

    # Calcular a média de curto prazo (STA) usando modo 'same' para manter o comprimento
    sta = np.convolve(signal ** 2, np.ones(nsta), 'same')

    # Calcular a média de longo prazo (LTA) usando modo 'same' para manter o comprimento
    lta = np.convolve(signal ** 2, np.ones(nlta), 'same')

    # Evitar divisões por zero
    sta_lta_ratio = np.zeros(len(signal))
    valid = lta != 0
    sta_lta_ratio[valid] = sta[valid] / lta[valid]

    return sta_lta_ratio

# Definir os tamanhos das janelas STA e LTA
nsta = 5  # Janela para STA
nlta = 50  # Janela para LTA

# Calcular a razão STA/LTA para o sinal filtrado
sta_lta_signal = sta_lta(df['filtered_time_rel'], nsta, nlta)

# Plotar o resultado da razão STA/LTA
plt.figure(figsize=(14, 7))
plt.plot(df['time_abs'], sta_lta_signal, label='Razão STA/LTA')
plt.axhline(y=2.0, color='r', linestyle='--', label='Limite de Detecção')  # Limite de detecção ajustável
plt.title('Detecção de Eventos com Método STA/LTA')
plt.xlabel('Tempo Absoluto')
plt.ylabel('Razão STA/LTA')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

